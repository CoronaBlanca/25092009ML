-- DESOFUSCADOR CON WEBHOOK DE DISCORD (VERSIÃ“N MEJORADA)
-- =========================================================

-- âš™ï¸ CONFIGURACIÃ“N
local WEBHOOK_URL = "https://discordapp.com/api/webhooks/1428150779838988299/dCT_aUK_Xdufmurz8t7cd5qtjmKljVYJ5UB2c-UvhkB-OsaJ64VGsXI-XRwR9wlZ_JKT" -- Pon tu webhook completo aquÃ­
local GITHUB_RAW_URL = "https://raw.githubusercontent.com/CoronaBlanca/2198832473482/refs/heads/main/dxsxfxscxtxr%20By%20Shxryx" -- O tu link

-- ğŸ“Š Captura profunda
local captured = {
    loadstring_calls = {},
    function_calls = {},
    getfenv_calls = {},
    setfenv_calls = {},
    debug_info = {},
    strings_found = {},
    variables = {}
}

print("ğŸ” Desofuscador Avanzado MoonSec V3")
print("=" .. string.rep("=", 49))

-- ğŸª HOOK LOADSTRING (mÃºltiples niveles)
local old_loadstring = loadstring
_G.loadstring = function(code, chunkname)
    print("ğŸ“¦ loadstring() llamado")
    
    -- Verificar si NO es el mismo cÃ³digo ofuscado
    if not code:find("MoonSec V3") then
        print("âœ… Â¡CÃ“DIGO NUEVO DETECTADO!")
        table.insert(captured.loadstring_calls, {
            code = code,
            size = #code,
            chunk = chunkname or "unknown"
        })
    else
        print("âš ï¸ Detectado cÃ³digo MoonSec (ignorado)")
    end
    
    return old_loadstring(code, chunkname)
end
loadstring = _G.loadstring

-- ğŸª HOOK LOAD
if load then
    local old_load = load
    _G.load = function(chunk, ...)
        if type(chunk) == "string" and not chunk:find("MoonSec") then
            print("ğŸ“¦ load() con cÃ³digo limpio detectado")
            table.insert(captured.loadstring_calls, {
                code = chunk,
                size = #chunk,
                source = "load()"
            })
        end
        return old_load(chunk, ...)
    end
    load = _G.load
end

-- ğŸª HOOK GETFENV (capturar variables globales creadas)
local old_getfenv = getfenv
getfenv = function(level)
    local env = old_getfenv(level)
    
    -- Capturar nuevas variables globales
    for k, v in pairs(env) do
        if type(v) == "function" and not captured.variables[k] then
            captured.variables[k] = true
            table.insert(captured.function_calls, {
                name = k,
                type = type(v)
            })
        end
    end
    
    return env
end

-- ğŸª HOOK DEBUG.GETINFO (capturar funciones generadas)
if debug and debug.getinfo then
    local old_getinfo = debug.getinfo
    debug.getinfo = function(func, what)
        local info = old_getinfo(func, what)
        
        if info and info.source and not info.source:find("MoonSec") then
            table.insert(captured.debug_info, {
                source = info.source,
                name = info.name or "anonymous",
                line = info.linedefined or 0
            })
        end
        
        return info
    end
end

-- ğŸª CAPTURAR STRINGS (buscar patrones de cÃ³digo)
local old_tostring = tostring
tostring = function(obj)
    local str = old_tostring(obj)
    
    -- Detectar si es cÃ³digo Lua
    if type(str) == "string" and #str > 50 then
        if str:find("local ") or str:find("function") or str:find("return") then
            if not str:find("MoonSec") then
                print("ğŸ” String con cÃ³digo detectado")
                table.insert(captured.strings_found, str)
            end
        end
    end
    
    return str
end

-- ğŸ“¤ FUNCIÃ“N PARA ENVIAR
local function send_to_discord(content, title)
    title = title or "Resultados"
    
    local preview = content:sub(1, 3900)
    
    local payload = game:GetService("HttpService"):JSONEncode({
        username = "MoonSec Hunter",
        embeds = {{
            title = "ğŸ”“ " .. title,
            description = "```lua\n" .. preview .. "\n```",
            color = 15158332,
            footer = {text = os.date("%H:%M:%S")}
        }}
    })
    
    pcall(function()
        request({
            Url = WEBHOOK_URL,
            Method = "POST",
            Headers = {["Content-Type"] = "application/json"},
            Body = payload
        })
    end)
end

-- ğŸ’¾ GUARDAR
local function save_file(content, name)
    if writefile then
        writefile(name, content)
        print("ğŸ’¾ Guardado:", name)
    end
end

-- ğŸš€ DESCARGAR Y EJECUTAR
print("\nğŸ“¥ Descargando cÃ³digo...")

local success, code = pcall(function()
    return game:HttpGet(GITHUB_RAW_URL, true)
end)

if not success then
    warn("âŒ Error:", code)
    return
end

print("âœ… Descargado:", #code, "bytes")

-- âš¡ EJECUTAR CON MÃXIMA CAPTURA
print("\nâš¡ Ejecutando con hooks activos...")
print("â³ Esto puede tardar unos segundos...\n")

-- Ejecutar
pcall(function()
    loadstring(code)()
end)

-- Esperar a que termine
wait(5)

print("\n" .. string.rep("=", 50))
print("ğŸ“Š ANÃLISIS DE CAPTURA")
print(string.rep("=", 50))

-- ğŸ“‹ ANALIZAR RESULTADOS
local report = "-- REPORTE DE DESOFUSCACIÃ“N MOONSEC V3\n"
report = report .. "-- Timestamp: " .. os.date() .. "\n"
report = report .. "-- " .. string.rep("=", 48) .. "\n\n"

-- 1. CÃ³digos capturados con loadstring
if #captured.loadstring_calls > 0 then
    print("âœ… Loadstring calls:", #captured.loadstring_calls)
    
    report = report .. "-- ========== CÃ“DIGOS EJECUTADOS ==========\n\n"
    
    for i, call in ipairs(captured.loadstring_calls) do
        report = report .. "-- CÃ³digo #" .. i .. " (" .. call.size .. " bytes)\n"
        report = report .. "-- Source: " .. (call.chunk or call.source or "unknown") .. "\n\n"
        report = report .. call.code .. "\n\n"
        report = report .. string.rep("-", 50) .. "\n\n"
    end
else
    print("âš ï¸ No se capturaron loadstring calls")
    report = report .. "-- âš ï¸ NO SE DETECTARON LLAMADAS A LOADSTRING\n\n"
end

-- 2. Funciones globales creadas
if #captured.function_calls > 0 then
    print("ğŸ“ Funciones detectadas:", #captured.function_calls)
    
    report = report .. "-- ========== FUNCIONES GLOBALES ==========\n\n"
    
    for _, func in ipairs(captured.function_calls) do
        report = report .. "-- " .. func.name .. " (" .. func.type .. ")\n"
    end
    report = report .. "\n"
end

-- 3. Strings con cÃ³digo
if #captured.strings_found > 0 then
    print("ğŸ”¤ Strings encontrados:", #captured.strings_found)
    
    report = report .. "-- ========== STRINGS CAPTURADOS ==========\n\n"
    
    for i, str in ipairs(captured.strings_found) do
        report = report .. "-- String #" .. i .. ":\n"
        report = report .. str .. "\n\n"
    end
end

-- 4. Info de debug
if #captured.debug_info > 0 then
    print("ğŸ› Debug info:", #captured.debug_info)
    
    report = report .. "-- ========== DEBUG INFO ==========\n\n"
    
    for _, info in ipairs(captured.debug_info) do
        report = report .. "-- Function: " .. info.name .. "\n"
        report = report .. "-- Source: " .. info.source .. "\n"
        report = report .. "-- Line: " .. info.line .. "\n\n"
    end
end

-- ğŸ“Š RESUMEN
print("\n" .. string.rep("=", 50))
print("ğŸ“Š RESUMEN FINAL")
print(string.rep("=", 50))
print("Loadstring calls:", #captured.loadstring_calls)
print("Funciones:", #captured.function_calls)
print("Strings:", #captured.strings_found)
print("Debug info:", #captured.debug_info)
print(string.rep("=", 50))

-- ğŸ“¤ ENVIAR Y GUARDAR
if #captured.loadstring_calls > 0 then
    print("\nâœ… Â¡Ã‰XITO! CÃ³digo capturado")
    send_to_discord(report, "CÃ³digo Desofuscado")
    save_file(report, "deobfuscated_success.lua")
else
    print("\nâš ï¸ NO SE CAPTURÃ“ CÃ“DIGO LIMPIO")
    print("\nğŸ’¡ Posibles razones:")
    print("   â€¢ MoonSec usa bytecode puro (sin loadstring)")
    print("   â€¢ Necesita mÃ©todo de captura diferente")
    print("   â€¢ El cÃ³digo ya estÃ¡ desofuscado")
    
    report = report .. "\n-- CÃ“DIGO ORIGINAL (sin desofuscar):\n\n"
    report = report .. code
    
    send_to_discord(report:sub(1, 3000), "AnÃ¡lisis sin cÃ³digo limpio")
    save_file(report, "analysis_report.lua")
end

print("\nğŸ Proceso terminado")
print("ğŸ’¾ Revisa los archivos generados en workspace")
